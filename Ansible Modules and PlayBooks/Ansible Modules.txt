--- (начало любого playbook)
- name: install (имя Playbook)
  hosts: all (хост на котором будет выполнятся задание)
  become: yes (значит что нужно выполнить от root)
  any_errors_fatal: true (любая ошибка в любом задании отменит работу всего playbook на всех хостах, указывается по желанию)

  vars: (под ним создаем переменные со значениями, которые будут глобальными в пределах playbook)
    source_file: ./hallo.txt (имя пременной и ее значение)
    destin_file: /root/ansible/hi.txt 
    secret: 30968350640690  
    
  tasks: (ниже создаем параметры задания)
  - name: install packs (имя задания)
    apt: (пакетный менедер)
     name: "{{ packages }}" (переменная с списком пакетов) (если указать "*" в name то сделает апгрейд всех пакетов)  
     state: latest (статус версии) (state=absent чтобы удалить)
     autoclean: yes (Удаляет ненужные пакеты из кеша, лучше запускать отдельным заданием) 
     autoremove: yes (Удаляет зависимости, которые больше не нужны, всегда запускать отдельным заданием только с удалением пакетов)
     update_cache: yes (работает как apt-update)
     deb: https://example.com/python-ppq_0.1-1_all.deb (Для установки deb пакетов и добавления репо, )
     purge: yes (если стоит yes то принудительно очистит файлы конфигурации, если состояние модуля установлено как absent)
    vars: (ниже перечисляем пакеты которые планируем установить ввиде списка переменных, этот способ подходит если нужно сделать много установок не создавая для каждой программы задачу) 
     packages:(создаем переменную и перечисляем пакеты и программы)но можно и через цикл-> - name: install with cycle (имя задания)
       - wget                                                                                apt: name={{ item }} state=latest(пакетный менедер, имена пакетов в цикле и статус состояния)
       - mc                                                                                  loop: (ниже перечисляем имена пакетов для установки через этот цикл)         
       - neofetch                                                                             - httpd 
       - curl                                                                                 - httpd-devel                  
       - git                                                                                  - wget           
    when: ansible_os_family == "Debian" and/or ansible_distribution_version == "20.04" (пример того как можно использовать условия в задании с любым из логических операторов)          

  - shell: uptime (если хочешь посмотреть результат команды на контроллере то его можно сохранить в переменную)  
    register: result (модуль сохранения вывода, создаем переменную в которую запишем вывод)
    failed_when: result.rc == 0 или "'World' in result.stdout"(совпадение в условии отменит работу всего playbook на хосте, указывается по желанию, при обычных ошибках также остановится)

  - debug: (модуль вывода содержания переменой в консоль) (ниже указываем переменную из которой считаем результат команды на удаленном хосте) 
      var: result (переменная из модуля register) (но также можно сделать вывод значения и обычной переменной)

  - debug: (модуль вывода содержания переменой в консоль) (ниже можно указать ввиде сообщения с переменной) (иной пример)
      msg: "Secretnoe {{ secret }}" (вывод в виде сообщения)

  - name: commands (имя задания) (пример того как можно в одном задании через цикл выполнить ряд команд на удаленном хосте и при этом не создавать для каждой команды отдельное задание)
    shell: "{{item}}" (модуль команд, внутри переменной item хранится список команд которые перечислены в цикле)
    args: (ниже указываем модуль смены оболочки) (/bin/sh не обрабатывает перенаправление и подстановочные знаки вместе, как показано в скобках ---> (cat < /tmp/*txt), а bash может)
      chdir: /root/ansible/dir(если нужно перед выполнением команд сменить папку то указываем путь до нее, если это нужно то лучше создать отдельную задачу чтобы выполнить нужную команду)
      executable: /bin/bash (этот модуль изменит оболочку, используемую для выполнения команды. Должен быть абсолютный путь к исполняемому файлу)
    loop: (модуль цикла, ниже перечисляем команды которые хотим выполнить на удаленном хосте)
      - touch /root/ansible/boom.txt && mkdir /root/ansible/boome (модуль shell использует оболочки и может выполнять команды с этими знаками "< > | ; &" как в этой строке)
      - mv /root/ansible/boom.txt /root/ansible/boome(модуль command работает как и shell но не может использовать оболочки и эти знаки "< > | ; &" и выполняет команды как в этой строке)

  - group: (модуль управления группами)
     name: james (имя группы)
     state: present (present - создать, absent - удалить)
     gid: 1200 (id группы)
                                                                                                                 - name: deleting of user (имя задания)
  - name: creating user (имя задания)                                                                              user:  (модуль управления пользователями)   
    user: (модуль управления пользователями)                                                                         name: james (имя пользователя)
     name: james (имя пользователя)                                                                                  state: absent (указываем что пользователь должен отсутствовать)
     group: james (добавить в указанную группу) (есть идентификатор gid=1000(james) )                                remove: yes (подтверждаем удаление)
     groups: angelo, devops (добавить в указанные группы) (и есть идентификатор groups=1000(james) ) 
     shell: /bin/bash (командная оболочка для пользователя)
     uid: 1104 (id пользователя)
     create_home: yes (создать домашнюю папку)
     home: /home/james/ (путь до домашней папки)
     state: present (указываем что учетная запись должна существовать) 
     append: yes (Если yes добавить пользователя в группы, указанные в groups. Если no, пользователь будет добавлен только в группы, указанные в groups, удалив их из всех остальных групп)
       
  - authorized_key: (модуль добавления публичного ssh ключа пользователю) (смена расположения по желанию)
     user: james (имя пользователя)
     state: present (статус ключа - должен ли ключ с заданными опциями быть или не быть в файле)
     key: "{{ lookup('file', '/root/authorized_keys') }}"(тип того из чего берем содержимое и путь откуда брать содержимое для передачи, путь хранения указываем свой)(lookup это функция) 
     path: /home/james/ssh/authorized_keys(меняем расположение ключа при желании, для подключения добавляем путь до ключа на хосте в файле /etc/ssh/sshd_config в поле AuthorizedKeysFile)
     manage_dir: False (если меняем расположение ключа то советуют ставить такое значение что бы потом была возможность подключиться по ssh)   

  - name: install web (имя задания, разовая установка)                                    - name: install repo (пример установки rpm пакетов и добавления репо по пути /etc/yum.repos.d/)
    yum: (пакетный менедер)                                                                 yum: (паетный менеджер)
     name: nginx (имя пакета) (если указать "*" в name то сделает апгрейд всех пакетов)       name: https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm
     state: latest(версия, absent чтобы удалить) (installed, latest, present, removed)        state: present  (статус)
     security: yes (Если задано значение yes, а state=latest, то устанавливает только обновления, помеченные как связанные с безопасностью)
     update_cache: yes (Заставьте yum проверять не устарел ли кеш и при необходимости обновить его. Имеет эффект только в том случае, если состояние present или является latest)
     download_only: yes (только скачает, не установит их)
     autoremove: yes (Удаляет зависимости, которые больше не нужны, всегда запускать отдельным заданием только с удалением пакетов)
     exclude: kernel*,foo* (указываем пакеты которые не хотим апгрейдить, когда состояние = present или latest)
     update_only: yes (обновляет только установленные пакеты. Не устанавливает пакеты, Действует только в том случае, если состояние является latest)
    when: ansible_os_family == "RedHat" and ansible_distribution_version == "7.9" (пример того как можно использовать условия в задании с любым из логических операторов)

  - name: Coping Myhome (имя задания)
    copy: (модуль копирования) (может заменить существующий файл на хосте если имена совпадают)
      src: "{{ source_file }}" (переменная из которой берем путь источника если определили раннее, если нет, то просто указываем полный путь)
      dest: "{{ destin_file }}" (переменная с путем назначения если определили раннее, если нет, то просто указываем полный путь)
      mode: '0777'(права для файла)(если копируем папку в папку то для определения прав можно использовать поле directory_mode: вместо поля mode:)(папкам нельзя добавить стики-биты '0777')
      owner: angelo (владелец)
      group: angelo  (группа владельцев) 
      backup: yes (если перед заменой нужно создать копию оригинала)
      remote_src: yes (если файл или папка из поля src: находятся на удаленном хосте)
    notify: Restart web (напоминание что нужно сделать рестарт службы в этой точке, отсюда его и вызываем - это пример работы handlers)
    
    copy: src=/root/{{item}} dest=/root/ansible/{{item}} mode=0777 owner=angelo group=angelo(копирование указанных файлов из папки в папку) ( {{item}} - это то, что берем из цикла )
    loop: (в этом цикле указываем файлы которые собираемся копировать) (если в src и dest укажем только пути папок без item и цикла то копирует папку в другую папку со всем содержимым)
     - ter
     - tex
     - tez

  - file: (модуль создания папок и файлов) 
      path: /root/ansible/red/bot/mydir (если этого пути не существует, то модуль последовательно создаст этот путь с папками, которые указаны в поле path:)
      state: directory(создать папку - state: directory и создать файл - state: touch)(так же можно создавать папки и файлы через цикл с указанием {{item}} в конце пути)
      owner: angelo (имя владельца)
      group: angelo (имя группы владельцев)
      mode: '777' (права) (только файлам можно добавить стики-биты '0777')
    delegate_to: myhost(альтернатива для назначения задания на хост по имени)

  - file: (пример того, как рекурсивно поменять состояние содержимого в папке, самой папки и изменить состояние файла, данный пример работает как утилита chmod/chown)
      path: /root/ansible (путь) (если состоянияе того чего хотим изменить не сущестует то модуль это создаст)
      state: directory (статус) (если нужно изменить состояние файла то указываем путь до файла и указываем state: file и убираем поле recurse:)
      recurse: yes (указываем что действие должно быть рекурсивным, если действие рекурсивное то меняется состояние папок и файлов внутри, если без поля recurse: yes то только у папок)
      owner: root (имя владельца)
      group: root (имя группы владельцев)
      mode: '777' (права) (только файлам можно добавить стики-биты '0777')
    loop: (можно через цикл указать имена файлов или папок если нужно произвести действие выборочно, только путь будет выглядеть так path: /root/ansible/{{item}})
     - my.txt
     - you.txt
     - test.txt

  - name: start web (имя задания)
    service: (модуль сервиса)
      name: nginx (имя сервиса)
      state: started (ожидаемое состояние)
      enabled: yes (если нужно, то добавляем службу в автозагрузку после перезагрузок хоста, что бы запускалась самостоятельно, но можно и убрать из нее если указать no)  
   
  handlers:(для перезапуска служб, сам по себе не сработает, его нужно вызвать в указанной точке в playbook)(но рестарт можно сделать и через обычное задание в service state=restarted)
  - name: Restart web (имя задания)
    service: name=nginx state=restarted (модуль сервиса, имя сервиса, ожидаемое состояние)

  - name: Create a ext4 filesystem on /dev/sdb1 and check disk blocks (имя задания) 
    filesystem: (модуль создания файловой системы)(стоит помнить что перед принудительной сменой или созданием файловой системы раздел сначала нужно отмонтировать, иначе будет ошибка)
     fstype: ext4 (Тип создаваемой файловой системы)
     dev: /dev/sdb1 (путь к устройству )
     opts: -cc (Список параметров, передаваемых команде mkfs, то есть - ключи, не обязательное поле)
     force: yes (Если yes, позволяет создавать новую файловую систему на устройствах, на которых уже есть файловая система)

  - name: module of founding (имя задания)
    find: (модуль поиска) (чтобы вывести результат поиска в терминал, который записан в переменную и узнать точное расположение, то используй модуль debug: с указанием ниже переменной)
      paths: /tmp (путь до того места где будем искать)
      age: 2d (возраст того что ищем)
      recurse: yes (делать рекурсивный поиск или нет, можно указать no)
      size: 1m (размер того что ищем)
      patterns: '*.old,*.log.gz' (шаблон поиска)(это работает как фильтр)
      use_regex: yes(это поле указываем если используем выражения типа "^.*?\\.(?:old|log\\.gz)$", иначе при такой записи '*.old' будет ошибка ведь это относится к другому типу выражения)
      file_type: "{{item}}" (тип того что ищем из указанного в цикле)                            - find: (модуль поиска)(пример того как вывести только путь)
      excludes: 'nginx,mysql' (указываем исключения из поиска)                                       paths: / (путь до того места где будем искать)                                  
      hidden: yes (если хотим искать и скрытые тоже)                                                 recurse: yes (делать рекурсивный поиск или нет, можно указать no)            
    loop:(если искать что-то одно, цикл можно не создавать, вместо item указать что-то одно)         patterns: 'ansible' (шаблон поиска) (это работает как фильтр)              
      - directory                                                                                    file_type: file (тип того что ищем) (указывать только один тип искомого)
      - file                                                                                       register: files (переменная в которую записана вся информация, через debug выводим пути)
    register: result (переменная в которую записана вся информация о результате работы find)     - debug: msg="{{ files.files | sort(attribute='ctime') | map(attribute='path') | list }}"
    
  - name: Mount up device by label (имя задания) 
    mount: (модуль монтирования, создает запись в /etc/fstab чтобы раздел монтировался при загрузке)
     path: /srv/disk (Путь к точке монтирования)
     src: /dev/sda4 (путь к разделу который будем монтировать, но можно и так src: UUID=b3e48f45-f933-4c8e-a700-22a159ec9077  id-устройства можно задать любой)
     fstype: ext4 (файловая система раздела)
     opts: ro,rw (задать опции для управления состоянием раздела)
     state: mounted(absent - удалит из fstab, отключит устройство и удалит точку монтирования, mounted - будет подключено в fstab, present - будет настроено в fstab, без запуска и монтирования, unmounted - отключит без изменения fstab)
 
  - name: Run a script (имя задания) 
    script: /some/local/script.sh (путь до скрипта, который находится на контроллере ansible, удаленные скрипты лучше запускать через модуль shell: /path/to/remote_script так быстрее)

  - template:(модуль копирования шаблонных файлов)(также можно в файле указать переменную из playbook по типу host: "{{host}}" в скобках имя переменной из playbook, а не значение)
      src: /root/ansible/templ.j2 (путь откуда брать файл)(файл должен быть в формате j2, шаблонные переменные могут выглядеть так host: "{{ansible_host}}" эта переменная из инвентаря)
      dest: /root/ansible/templ.txt (точка назначения на удаленном хосте, можно создать новый файл, а можно указать существующий и перезаписать его)
      owner: root (указываем того кто будет владельцем)
      group: root (указываем группу которая будет владельцем)
      mode: 777 (права файла)
      backup: yes (указываем что нужно создать копию файла в той же папке перед его изменением)

  - name: copy a file to ansible-controller (имя задания)
    fetch: (модуль копирования файлов с удаленного хоста на)
     src: /root/ansible/ter.txt (путь откуда брать файл с удаленного хоста, обязательно указываем имя файла)
     dest: /root/ansible/ret.txt (путь куда положить файл на ansible-controller, имя файла не обязательно указывать в конце, но нужно будет добавить параметр flat: yes)
     flat: yes (переопределяет поведение по умолчанию, если dest оканчивается на '/', он будет использовать базовое имя исходного файла, это удобно только если имена файлов уникальны)
     fail_on_missing: yes (указываем, что задача завершится ошибкой, если удаленный файл не может быть прочитан по какой-либо причине)
     validate_checksum: yes (указываем что после получения файлов нужно убедиться, что контрольные суммы источника и назначения совпадают)

  - name: Replace a localhost entry with our own
    lineinfile:
      path: /etc/hosts (путь к файлу в котором нужно заменить указанную в выражении строку, по умолчанию, поле regexp делает замену только в последнем совпадении, если есть и другие)
      regexp: '^127\.0\.0\.1' (если выражение указанно в regexp и дополнительно указанно в insertafter или insertbefore, то они учитываються, только если совпадение для regexp не найдено)
      line: 127.0.0.1 localhost maylo
      owner: root (указываем того кто будет владельцем, по необходимости)
      group: root (указываем группу которая будет владельцем, по необходиости)
      mode: '0644' (права файла, по необходимости)
      insertbefore: '^#log' (строка из поля line будет вставлена ​​перед указанной строкой в выражении, если вместо выражения указать это BOF то вставит в начало)
      insertafter: '^#log' (строка из поля line будет вставлена ​​после указанной строки в выражении, если вместо выражения указать это EOF то вставит в конец)
      backup: yes (указываем что нужно создать копию файла в той же папке перед его изменением)
      firstmatch: yes (если необходимо то указываем что нужно заменить первое попавшееся совпадение)
      create: yes (указываем что нужно создать файл и в него добавить указанную строку из поля line, если указанный файл в поле path не существует, используется без полей с выражениями)

  - name: Print the apt package facts (имя задания)
    package_facts: (модуль вывода информации о пакетах)
      manager: apt (типы доступных пакетных менеджеров для проверки rpm, apt, portage, pkg и режим auto)
  - debug:  (модуль вывода содержания переменой в консоль)
      msg: "{{ ansible_facts.packages['wget'] }}" (указываем переменную и пакет о котором хотим получить информацию)
    when: "'wget' in ansible_facts.packages" (условие что данный пакет должен присутствовать в списке пакетов, который хранится в переменной ansible_facts.packages)

  - name: populate service facts (имя задания)
    service_facts: (модуль вывода информации о сервисах)
  - debug: (модуль вывода содержания переменой в консоль)
      msg: "{{ ansible_facts.services['cron.service'] }}"(переменная и служба о которой получим информацию, если хотим информацию в systemd то указываем имя.service если в sysv то имя)
    when: "'cron.service' in ansible_facts.services" (условие что данная служба должна присутствовать в списке служб, который хранится в переменной ansible_facts.services)

  - name: create temporary build directory (имя задания)
    tempfile: (модуль создания временных файлов и папок, между префиксом и суффиксом создаст любой набор букв, доступно только создателю) 
     path: /root/ansible/ (Место, где должен быть создан временный файл или каталог)
     state: directory (тип того что создаем)
     prefix: dir (то что будет в начале названия)
     suffix: me (то что будет в конце названия)

  - assemble: (этот модуль обьединяет все файлы в папке в один, файлы собираются в порядке строковой сортировки, в лексикографическом порядке названия файла по алфавиту "первой буквы")
     src: /root/ansible (путь до папки в которой лежат файлы которые нужно обьединить в один, если файлы имеют разное название то обьединяет их в том порядке в котором идут в папке)
     dest: /root/ansible/conf.cfg (путь до папки где будет создан указанный файл с именем conf.cfg)
     delimiter: '#----------------------' (если нужно то можно указать разделитель любого строкового типа между частями которые будут в одном файле)
     backup: yes (если нужно то создаем backup если затираем тот файл который уже существует)
     group: root (указываем группу которая будет владельцем)
     owner: root (указываем того кто будет владельцем)
     mode: 777 (права файла)
     ignore_hidden: yes (указываем нужно ли игнорировать файлы которые начинаются с точки, как скрытые)
     remote_src: yes (если нужные файлы для обьединения находятся на удаленном хосте то указываем yes)
     regexp: 't*.co*' (если нужно обьединить только конкретные файлы то можно задать выборку через регулярное выражение)
    
  - name: restart (имя задания)
    systemd: (модуль управления службами через systemd)
      state: restarted (ожидаемое состояние, started и stopped это идемпотентные действия, которые не будут запускать команды без необходимости, reloaded работает не со всеми службами)
      daemon_reload: yes (перечитываем конфигурационный файл systemd, как пример, если создали самописный демон, тогда нужно, или если делали измениния в конфигурационных файлах systemd)
      name: cron.service (имя сервиса, на каждом дистрибутиве имена могут отличаться, при использовании в среде chroot всегда нужно указывать полное имя)
      enabled: yes (если нужно, то добавляем службу в автозагрузку после перезагрузок хоста, что бы запускалась самостоятельно, но можно и убрать из нее если указать no)

  - name: Creating database (имя задания)
    mysql_db: (модуль создания базы)
     name: zabbix_db (имя базы)
     encoding: utf8  (Используемый режим кодирования, примеры включают utf8 или latin1_swedish_ci, при создании базы данных, дамп или импорт скрипта sql)
     collation: utf8_bin (Режим сопоставления (сортировка). Это относится только к новым таблицам / базам данных и не обновляет существующие, это ограничение MySQL.)
     state: present (в статусе указываем что должен присутствовать)
  
  - name: Create database user (имя задания)
    mysql_user: (модуль создания пользователя в базе)
     name: zabbix_user (имя пользователя)
     password: passw0rd123 (пароль)
     priv: '*.*:ALL,GRANT' (права)
     state: present (в статусе указываем что должен присутствовать)

  - firewalld:
      port: 10050-10051/tcp (можно указать диапозон или один порт и протокол, поля port: и service: определяются в разных заданиях, в одном задании можно открыть порт или добавить сервис)
      service: https (добавляем правило для сервиса и разрешаем пропускать через него трафик)
      zone: internal(Зона для добавления, удаления. Возможные значения включают block, dmz, drop, external, home, internal, public, trusted, work) (можно добавлять во всех заданиях)
      interface: ens33 (Интерфейс, который нужно добавить, удалить в, из зоны в firewalld, пример zone: trusted)(interface конфигурировать в отдельном задании без полей port: и service:)
      rich_rule: rule forward-port port=443 protocol=tcp to-port=8443(гибкие правила для добавления, удаления в, из firewalld)(указывать в отдельных заданиях без полей port: и service:)
      immediate: yes (указываем что конфигурация будет применена немедленно, если установлено поле permanent: yes)
      permanent: yes (указываем должна ли эта конфигурация быть в текущей конфигурации firewalld или сохраняться при перезагрузках)
      state: enabled (указываем что правила для порта или сервиса должны быть включены)
  
  - name: Add repository (имя задания) (некоторые поля указываются по необходимости)
    yum_repository: (модуль управления репозиториями)
     name: grafana (имя репо)
     description: grafana (описание)
     baseurl: https://packages.grafana.com/oss/rpm (url расположение репо)
     mirrorlist: http://mirrorlist.repoforge.org/el7/mirrors-rpmforge (Задает URL-адрес файла, содержащего список базовых URL-адресов, это поле предусмотрено не во всех репо)
     metalink: https://mirrors.fedoraproject.org/metalink?repo=epel-7&arch=$basearch&infra=$infra&content=$contentdir (Задает URL-адрес файла metalink для repomd.xml, есть не во всех репо)
     gpgkey: https://packages.grafana.com/gpg.key (URL-адрес, указывающий на защищенный ASCII ключевой файл GPG для репозитория)
     sslverify: yes (Определяет, должен ли yum вообще проверять SSL-сертификаты / хосты)
     sslcacert: /etc/pki/tls/certs/ca-bundle.crt(Путь к файлу, содержащему базы данных центров сертификации, которые используются для проверки сертификатов)(доп.файл ca-bundle.trust.crt)
     gpgcheck: yes (Сообщает yum, следует ли выполнять проверку подписи GPG для пакетов)
     repo_gpgcheck: yes (Это сообщает yum, следует ли выполнять проверку подписи GPG для реподанных из этого репозитория)
     enabled: yes (активируем репо)
     state: present (статус репо - absent чтобы удалить)

  - name: Install (имя задания)
    grafana_plugin: (модуль управления плагинами)
     grafana_plugin_url: https://storage.googleapis.com/plugins-community/alexanderzobnin-zabbix-app/release/4.1.5/alexanderzobnin-zabbix-app-4.1.5.zip (можно дополнительно указать url)
     name: alexanderzobnin-zabbix-app (полное имя плагина)
     grafana_plugins_dir: /path/to/dir (Каталог, в который будет установлен плагин Grafanaб, но это по желанию и необходимости)
     version: latest (версия плагина)
     state: present (Статус плагина Grafana - absent чтобы удалить)

  - parted: (модуль управления дисками)
      device: /dev/sdb (диск который будем размечать)
      number: 1 (номер раздела которой создадим)
      label: msdos (тип таблицы разделов, ставиться на весь диск и ставиться один раз, а не на раздел диска, доступно aix, amiga, bsd, dvh, gpt, loop, mac, msdos, pc98, sun)
      flags: [ lvm ] (флаг раздела, под что создаем раздел)
      part_start: 4096MB (начало раздела)
      part_end: 7090MB (конец раздела, если хотим изменить размер раздела то указываем только новый конец)
      part_type: primary (тип раздела, доступно extended, logical, primary)
      unit: MB (значение величины, указываем это поле только если начало и конец определяем в процентах, доступно MB, MiB, GB, GiB, TB, TiB)
      state: present (статус раздела, доступно absent, present, info)

  - blockinfile:
     path: /etc/yum.repos.d/elastic.repo
     create: yes
     block: |
      [elasticsearch]
      name=Elasticsearch repository for 7.x packages
      baseurl=https://artifacts.elastic.co/packages/7.x/yum
      gpgcheck=1
      gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
      enabled=1
      autorefresh=1
      type=rpm-md