systemctl --failed (покажет упавшие службы) systemctl list-unit-files (покажет список всех демонов и статус коротко) systemctl --all (покажет статус служб развернуто, но только запущеные)
ps ax | grep "nodejs" | wc -l (Считаем количество процессов nodejs)  ps -ef | awk '{ print $8 }' | sort -n | uniq -c | sort -n | tail -5 (Считаем количество процессов в системе и выводим 5, которые запустили больше всего экземпляров)
id имя пользователя (покажет id групп и т.д.) groups имя пользователя (покажет группу) lsof -p 1028 (показывает все файлы, которые открывает процесс, или все процессы, которые открывают файл)
journalctl -f (выводит события системы в реальном времени) journalctl -n 10 (выводит указанное кол-во строк последних событий в системе, любое, какое укажешь)
journalctl --since "2021-06-16 17:00:00" --until "2021-06-16 20:00:00" -u sshd.service (покажет все события в указанном диапозоне по выбранному демону) 
journalctl -p 4(по уровню важности)(0 неработоспособность системы,1 нужно вмешаться,2 критическое состояние,3 ошибки,4 предупреждения,5 уведомления,6 информационные sms,7 отладочные sms)
journalctl /usr/sbin/nginx --since today (можно просмотреть лог приложения, указав его исполняемый файл или его PID (journalctl _PID=1) )
yum autoremove имя пакета (удалить пакет и стереть все ненужные зависимости)  yum remove имя пакета (удалить пакет) sudo --user=username команда (выполнить команду от указанного пользователя не вводя пароль)
yum list | grep имя пакета (Если нужно удалить пакет, но не уверен в его точном имени то можно посмотреть так)  rpm -qa | grep имя пакета (тоже самое только покажет другие пакеты)
file red.txt (выведет информацию о файле) file -s /dev/sda1 (если раздел не смонтирован то этой комндой можно посмотреть тип файловой системы) 
ls *.txt | xargs rm -f(пример работы с xargs. передаем их одной строкой) ls y* | xargs rm -rf && ls t* | xargs rm -rf (пример логического "и" сначала эту команду потом эту)
jobs (выведет все процессы, которые запущены в фоновом режиме) 
ps aux (сделает снимок процессов из диспетчера задач выведет его в терминале) ps -eo user,pid,pcpu,nice,comm (выведет снимок активных процессов по указанным полям, но их может быть больше или меньше)
killall sleep (убьет все процессы с именем, которое укажем)  pkill sleep (завершает процесс), pstree (покажет дерево процессов), free (покажет загруженность оперативки)
pgrep sleep -l (отсортирует и выведет процессы по указанному имени процесса)  pgrep -u akakiev -l(отсортирует и выведет все процесы указанного пользователя) renice 15 -u akakiev (изменит приоритет всех процессов пользователя)
du -chs ansible red (выведет размер папок по указанному пути. если уже в папке то просто перечисляем папки в папке, если нет, то указываем полные пути с места просмотра /root/ /home/misha)
du -hс --max-depth=2 /root(задает глубину папок для просмотра Если задать глубину равную 2 то можно посмотреть общие размеры всех папок по пути не дальше двух вложений с места просмотра)
fsck -t ext4 /dev/sda1 (проверяет указанную файловую систему в разделе)  dumpe2fs /dev/sda1 > info.txt (выводим информацию о файловой системе в файл)
scp -r user@ip or domain of server1:/path/to/dir/ -P 22 user@:ip or domain of server2:/path/to/dir/(копирование папок через указанный порт по ssh на другой хост)cp -r /etc/apache/ /backup/ (рекурсивно копирует одну дерикторию в другую)
find / -name имя файла или дериктории(ищет указанный файл или дерикторию там где укажем по имени)findmnt -l (вывести точки монтирования списком, а не деревом)findmnt -s (смонтированы в fstab)findmnt -t ext4 (по типу файловой системы)
tail -n 10 имя файла (выведет указанное кол-во строк с конца файла) less -S (что бы не переводил на новую строку) mkdir /long/path/ -p рекурсивно создать папки по указанному пути
grep -n hallo t.txt (Чтобы показать номер строки, где была найдена искомая строка) grep -i -r Hallo /root (ищет слово рекурсивно везде где укажем, с ключом -i независимо от регистра)
grep -r Hallo /root (Чтобы вести поиск среди всех файлов по указанному пути рекурсивно)  grep -e World -e Hallo -e mir -e 'my home' t.txt (ПОИСК ПО НЕСКОЛЬКИМ СЛОВАМ)
zgrep/grep --color=always '100' ./app.log_2021-04-13* | grep --color=always 'IT' (если нужно грепнуть другой греп, пример синтаксиса и передачи вывода для второго "grep")
zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -u zabbix_user -p zabbix_db -ppassw0rd123(через ключ -p и пароль слитно выполняем команду с автозаполнением пароля - пример)
htpasswd -b /etc/nginx/htpasswd.users username password (создаем файл с логином и паролем для авторизации в веб-интерфейсе того приложения для которого после создадим конфиг nginx и в котором укажем путь до этого файла)
top (откроет диспетчер задач, поле load average —  среднее значение загрузки системы за период времени, в виде трёх значений, за последние 1, 5 и 15 минут, чем ниже, тем лучше)
udevadm settle (выполнит переопознание разделов после разметки диска, чтобы их потом можно было увидеть новые разделы в файле /proc/partitions)
pvcreate /dev/имя раздела (создаем физический раздел для LVM, на каждом таком разделе должна стоять метка LVM) vgcreate имя группы томов /dev/имя раздела /dev/имя раздела ... (создаем группу томов и добавляем в нее физические разделы) 
lvcreate -n lv-name -L 3G имя группы томов (создаем логический раздел с указанным размером поверх группы томов, после в этом разделе нужно создать файловую систему и смонтировать его в выбранную папку) 
lvextend vg-name/lv-name -L +100MB -r (увеличить или уменьшить размер тома и файловой системы тома разом) mount -a (монтируем все записи из /etc/fstab) vgextend vg-name /dev/sdb1 (расширяем группу на +1 физический том)
pvdisplay /dev/имя раздела (просмотр информации о pv LVM с подробным отчетом для каждого тома) pvscan (проверяет блочные устройства на наличия физических томов) pvs, lvs, vgs (покажет информацию объектов LVM коротко)
pvresize /dev/имя раздела (изменяет размер физического тома, если изменился размер блочного устройства в его основе) pvremove /dev/имя (удаляет устройство, в котором больше нет необходимости, заполняя его метаданные нулями)
vgdisplay vg-name (просмотр информации о vg LVM с подробным отчетом) vgscan (проверяет дисковые устройства в системе на наличия физических томов и групп томов) vgreduce vg-name /dev/имя раздела (удалит физический том из vg)
vgremove vg-name (удалит пустую группу томов) vgsplit vg-name"1" vg-name"2" /dev/имя раздела (отделяет vg-2 с pv от vg-1 чтобы разделить физические тома в группе с целью создания новой группы)
vgmerge -v vg-name"1" vg-name"2" (добавит vg-2 в группу vg-1 если размеры их физических экстентов равны и общий объем физических и логических томов обеих групп не превышает допустимый размер полученной группы)
vgrename vg-name"1" vg-name"2" (изменяет имя группы vg-1 на имя vg-2) lvcreate -L 50G -i2 -I64 -n lv-name vg-name (создаст lv 50 ГБ на основе двух физических томов в группе и размер сегмента чередования 64 КБ)
lvrename vg-name lv-name"1" lv-name"2" (изменит имя lv-1 на имя lv-2 в vg) lvremove /dev/vg-name/lv-name (удалит lv) lvdisplay -v /dev/vg-name/lv-name (просмотр информации о lv LVM с подробным отчетом)
pvmove -b -i5 /dev/sda1 /dev/sdb1 (переместит все распределенные сегменты тома /dev/sda1 на /dev/sdb1 в фоновом режиме c отчетом каждые 5 секунд) lvs -P -a -o +devices (выводит список неисправных lv) 
vgs -P -o +devices (выводит список vg c неисправными lv) lvcreate -L 50G -m1 -n lv-name vg-name (создаст зеркальный lv в указанной vg с одним уровнем зеркалирования данных поверх 2-х pv, данные пишуться на два диска)
curl -Lqk -x http://10.7.200.8:3129 https://github.com/topolvm/topolvm/releases/download/v0.6.0/lvmd-0.6.0.tar.gz --output lvmd-0.6.0.tar.gz (качаем архив через прокси)
