Виртуа́льная па́мять - это адресное пространство выделеное конкретному процессу, то есть, диапозон адресов которыми можно аперировать. Они не обязаны как-то быть выражены физической памятью, например, приложение запросило много памяти, но пока никак не использует, железную память можно пока никак не тратить, если есть необходимость сделать запись, то может быть сопоставлено адресное пространство виртуальной памяти с физическим адресным пространством оперативной памяти комьпютера, в таком случае выделяется резидентная память и в нее сохраняется значение. Это метод управления памятью компьютера позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем (например, жёстким диском). 
Для выполняющейся программы данный метод полностью прозрачен и не требует дополнительных усилий со стороны программиста, однако реализация этого метода требует как аппаратной поддержки, так и поддержки со стороны операционной системы.
В системе с виртуальной памятью используемые программами адреса, называемые виртуальными адресами, транслируются в физические адреса в памяти компьютера. Трансляцию виртуальных адресов в физические выполняет аппаратное обеспечение, называемое блоком управления памятью. Для программы основная память выглядит как доступное и непрерывное адресное пространство либо как набор непрерывных сегментов, вне зависимости от наличия у компьютера соответствующего объёма оперативной памяти. Управление виртуальными адресными пространствами, соотнесение физической и виртуальной памяти, а также перемещение фрагментов памяти между основным и вторичным хранилищами выполняет операционная система (см. подкачка страниц).
Виртуальная память-это представление RAM плюс, возможно, некоторое пространство подкачки, предоставляемое менеджером виртуальной памяти. Современные OSs имеют менеджеры виртуальной памяти и предоставляют виртуальную память процессам, чтобы исполняющая программа могла вести себя так, как если бы у нее было непрерывное адресное пространство, размер которого не ограничен фактическим RAM. Страницы или блоки, составляющие виртуальную память, могут быть сопоставлены в любом месте RAM, так что виртуальные страницы contiguos должны храниться в областях contiguos RAM. Или они могут быть заменены на пространство страницы или пространство подкачки, ожидая там до тех пор, пока это не потребуется, после чего они будут прочитаны OS и сопоставлены с какой-либо страницей RAM. Некоторые или все страницы памяти, принадлежащие процессу, могут быть заменены
Применение виртуальной памяти позволяет:
освободить программиста от необходимости вручную управлять загрузкой частей программы в память и согласовывать использование памяти с другими программами
предоставлять программам больше памяти, чем физически установлено в системе
в многозадачных системах изолировать выполняющиеся программы друг от друга путём назначения им непересекающихся адресных пространств (см. защита памяти)
В настоящее время виртуальная память аппаратно поддерживается в большинстве современных процессоров. В то же время в микроконтроллерах и в системах специального назначения, где либо требуется очень быстрая работа, либо есть ограничения на длительность отклика (системы реального времени), виртуальная память используется относительно редко. Также в таких системах реже встречается многозадачность и сложные иерархии памяти.


Socket — название программного интерфейса для обеспечения обмена данными между процессами, он же, специальный файл, используемый для межпроцессного взаимодействия, который обеспечивает связь между двумя процессами. Помимо отправки данных, процессы могут отправлять файловые дескрипторы через соединение сокета домена Unix с помощью системных вызовов sendmsg () и recvmsg (). Процессы могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения в канале двусторонней связи. Подпрограммы сокета создают канал связи, и этот канал используется для передачи данных между прикладными программами локально или по сети. Каждый сокет в сети имеет уникальное имя, связанное с ним, называемое дескриптором сокета - целое число, обозначающее сокет и позволяющее прикладным программам обращаться к нему при необходимости. Используя электрическую аналогию, 
вы можете представить канал связи как электрический провод с вилкой и представить порт или розетку как электрическую розетку или розетку. Когда клиент запускает вызов сокета, соединение сокета устанавливается между приложением на клиенте и приложением на сервере. Другая аналогия, используемая для описания связи через розетку, - это телефонный разговор. Набор номера с телефона аналогичен вызову через розетку. Блок телефонной коммутации знает, где логически сделать правильный переключатель для завершения вызова в удаленном месте. Во время телефонного разговора это соединение присутствует и происходит обмен информацией. После того, как вы положите трубку, соединение будет разорвано, и вы должны будете запустить его снова. Клиент использует вызов функции socket () для запуска механизма логического переключения для подключения к серверу. Как и в случае с доступом к файлам, пользовательские процессы просят операционную систему создать сокет, когда он необходим. 
Система возвращает целое число, дескриптор сокета (sd), который приложение использует каждый раз, когда оно хочет обратиться к этому сокету. Основное различие между сокетами и файлами заключается в том, что операционная система связывает файловые дескрипторы с файлом или устройством, когда вызов open () создает файлвый дескриптор. С сокетами прикладные программы могут либо указать адрес назначения каждый раз, когда они используют сокет, например, при отправке дейтаграмм, либо привязать адрес назначения к сокету. В некоторых отношениях сокеты ведут себя как файлы или устройства UNIX, поэтому их можно использовать с такими традиционными операциями, как read () или write (). Например, после того, как две прикладные программы создают сокеты и открывают соединение между ними, одна программа может использовать write () для отправки потока данных, а другая может использовать read () для его получения. Поскольку каждый файл или сокет имеет уникальный дескриптор, система точно знает, куда отправлять и получать данные
В отличие от именованных каналов, которые допускают только однонаправленный поток данных, сокеты полностью поддерживают дуплекс. Можно ждать сокета, используя следующие функции асинхронного ввода-вывода: aio_read () - Асинхронное чтение из сокета, aio_write () - Асинхронная запись в сокет, aio_cancel () - Отменить запрос асинхронного ввода-вывода, aio_suspend () - Ожидание запроса асинхронного ввода-вывода, aio_error () - Получить статус ошибки для операции асинхронного ввода-вывода, aio_return () - Получить статус возврата для операции асинхронного ввода-вывода
Сокет домена Unix (англ. Unix domain socket, UDS) или IPC-сокет (сокет межпроцессного взаимодействия) — конечная точка обмена данными, подобная Интернет-сокету, но не использующая сетевой протокол для взаимодействия (обмена данными). Используется в операционных системах, поддерживающих стандарт POSIX, для межпроцессного взаимодействия. Доменные соединения Unix являются по сути байтовыми потоками, сильно напоминая сетевые соединения, но при этом все данные остаются внутри одного компьютера (то есть обмен данными происходит локально). UDS используют файловую систему как адресное пространство имен, то есть они представляются процессами как иноды в файловой системе. Это позволяет двум различным процессам открывать один и тот же сокет для взаимодействия между собой. Однако, конкретное взаимодействие, обмен данными, не использует файловую систему, а только буферы памяти ядра. Фактически - это двунаправленный канал, похожий на сокет TCP / IP. Сервер прослушивает и принимает соединения от клиентов, 
а затем может связываться с клиентом по вновь принятому соединению. Что особенного в доменных сокетах unix, так это то, что вместо IP-адреса и номера порта в качестве адреса используется имя файла. Это позволяет другим приложениям, которые ничего не знают о работе сети, получать информацию об открытии файла и чтении или записи, а данные отправляются на сервер, а не на диск.

Три основных компонента Linux
Source: https://frameboxxindore.com/android/what-are-the-main-components-of-linux.html
Ядро (kernel) - основной компонент ОС, отвечающий за управление процессами, виртуальной памятью и драйверами устройств.
Ядро Linux представляет собой единый блок бинарного кода. Все коды ядра и структуры данных, в том числе драйверы устройств, коды распределения ресурсов и виртуальной памяти, сетевой поддержки, а так же файловая система - хранятся в едином адресном пространстве. Преимуществом такой структуры является то, что не требуется никаких переключений при запросах процессами системных ресурсов или прерываниях от различных устройств.
Общее адресное пространство, однако, не препятствует модульности системы. По мере необходимости Linux подгружает в память либо выгружает из нее указанные модули.
В Linux все ядро работает в привилегированном режиме - режиме ядра. Никакая часть кода не работает в режиме пользователя. Фрагменты поддержки ОС, не требующие запуска в режиме ядра, помещаются в раздел системных библиотек.

Разделяемые системные библиотеки (system libraries) содержат стандартный набор функций, используемых приложениями для запросов к системным сервисам ядра. В библиотеках хранятся также код функций отдельных сервисов ядра, исполняемых в обычном режиме без привилегий ядра.
При обращении приложения к системным ресурсам управление от части системы, работающей в пользовательском режиме, передается ядру. Библиотеки осуществляют контроль за корректностью представленного запроса и преобразование параметров/аргументов запроса к требуемому формату.

Под системными утилитами (system utilities, программы управления системой) понимают программы, отвечающие за выполнение отдельных специализированных задач управления (управляющих функций системы). Одни утилиты запускаются лишь один раз для инициализации и конфигурирования отдельных элементов системы, другие вызываются регулярно, например, утилиты принимающие запросы на регистрацию с терминалов системы, либо утилиты обновляющие файлы регистрации.
Не все утилиты выполняют функции системного администрирования. Часть системных программ отвечают за выполнение простых задач, в частности, просмотр каталогов, перенос и удаление файлов, просмотр содержимого файла. Более сложные поддерживают некоторые функции обработки текстовых данных, например, сортировку данных либо поиск по заданному шаблону в тексте.